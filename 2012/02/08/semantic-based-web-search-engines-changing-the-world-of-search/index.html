<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Thoughts on latest technologies">

    <title>Semantic Based Web Search Engines Changing The World Of Search - Xebia Blog</title>

    <link rel="canonical" href="http://xebia.com/2012/02/08/semantic-based-web-search-engines-changing-the-world-of-search/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Xebia Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/">Home</a>
                </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Post Header -->
<header class="intro-header" style="background-image: url('/img/default-blog-pic.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Semantic Based Web Search Engines Changing The World Of Search</h1>
                    
                    <span class="meta">Posted by prachinagpal on February 8, 2012</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

				<h1>Semantic based web search engines- Changing the world of Search</h1>

<p>An important quality that the majority of search engines functional today lack is the ability to take into account the intention of the user behind the overall query. Basing the matching of web pages on keyword frequency and a ranking metric such as <a href="http://en.wikipedia.org/wiki/PageRank">Pagerank </a>return various results that may be of high ranking but still irrelevant to the users intended context. Therefore I explored with my friend Sumedha and realized that there  is a need to add <a href="http://en.wikipedia.org/wiki/Semantic_search">semantics</a> to the web search.</p>

<p>There are some semantic search engines that have already come up in the markets eg. Hakia, Swoogle, Kosmix, etc. that takes a semantic based approach which is different from the traditional search engines. I really liked their idea of  implementing and adding semantics to the web search. This provoked me to do more research in this field and tried to think of different ways to add semantics. </p>

<p>Following is an <em>Algorithm _that can be used in _Semantic Based Web Search Engines</em> :-</p>

<p>So, to find web pages on the internet that match a user’s query based not only on the important keywords in a user query, but also based on the intention of the user, behind that query, first the user’s entered query is expanded using <a href="http://en.wikipedia.org/wiki/WordNet">WordNet</a> ontology.</p>

<p>This Algorithm focuses on work that uses the <em>Hypernym</em>/<em>Hyponymy _and</em> Synset <em>relations in WordNet for query expansion algorithm. A set of words that are highly related to the words in the user query, determined by the frequency of their occurrence in the _Synset</em> and <em>Hyponym</em> tree for each of the user query terms is created.  This set is now refined using the same relations to get a more precise and accurate expanded query. </p>

<h1><strong>Query Expansion Using Semantics</strong></h1>

<p>Let the user input query consisting of a set of query terms Qi be:</p>

<p>Q = {q1, q2,...................qt}                                          (1)</p>

<p>The next step is to find the set <em>EQ</em> consisting of the semantically expanded user Query <em>Q</em>.</p>

<p>EQ = {eq1, eq2, .........eqm}                                         (2)</p>

<p>The set <em>EQ</em> can then be used to return a list of web pages that match the expanded query and are ranked according to highest relevance first. </p>

<h2><strong><em>Query Preprocessing</em></strong></h2>

<p>When the search engine is initially begun, a HashSet of commonly used English words is created globally, to be used for stop word removal each time a user query is inputted. This helps in elimination of noise data and reducing redundancy during context creation.</p>

<p>On the search engine, a user is asked to enter a String Query, <em>Q</em>. This query is now tokenized into separate <em>‘t’</em> Query terms by removing white spaces to get (1). We now perform stop word removal using the hashset of common English words defined during the backend processing to get a refined set of <em>‘n’</em> query terms,</p>

<p>Q&#39; = {q&#39;1, q&#39;2, ............... q&#39;n}                                     (3)</p>

<p>This set _Q _is now used for semantic query expansion. </p>

<h2><strong>_Algorithm _</strong></h2>

<p>The complete algorithm used for Query Expansion is:</p>

<p>_ _</p>

<p><em>Algorithm</em> : QueryExpansion</p>

<p><strong><em>Input</em></strong>: User Query</p>

<p><strong><em>Output</em></strong>: Refined Expanded Query</p>

<p>1.     Input_ Q = {q1, q2, …, qt}_ from user.</p>

<p>2.     Perform tokenization and stop word removal to get refined query <em>Q’ = {q’1, q’2, … q’n}</em></p>

<p>3.     Use synset <em>S(EQ)</em> and hyponymy relationships to get expanded query <em>EQ</em>.</p>

<p>4.     Create a hierarchical structure of terms <em>eqi</em> in expanded query to get context string <em>C</em>. </p>

<h1><strong>Finding Content for user Context</strong></h1>

<p>To find web pages that are relevant to the users’ intention, a directory of the web that categorizes web pages according to their content is needed. For this purpose, the <a href="http://www.dmoz.org/%20">Open Directory Project</a>, which is a human-edited directory of the web can be used. Similarly, to find text content that is related to the users’ intention, content can be extracted from the DBpedia.org Project (<a href="http://dbpedia.org/About">DBpedia</a>). It allows extraction of structured information from <a href="http://www.wikipedia.org/%20">Wikipedia</a>. </p>

<h2><strong><em>Retrieval of Relevant URLs</em></strong></h2>

<p>The <a href="http://www.dmoz.org/rdf.html">RDF dump</a> of the ODP provides a list of all the possible categories found within it . The Context String found after the QueryExpansion algorithm is matched to all the categories within the ODP to retrieve the top ten category matches. These top ten matches are then displayed to the user using our user-interface and he/she is asked to select the category that according to them is the closest to their intention. This is called <em>CAT.</em></p>

<p>Once we have the correct category, we can create an online connection to the ODP to retrieve all the URLs that fall within that category. This can be done by tokenizing the CAT string and passing it as a query to the ODP search box. </p>

<h2><strong><em>Retrieval of Relevant Content</em></strong></h2>

<p>Now to display some relevant, concise text content to the user, along with the URLs, so that the user has immediate access to some information related to his user query. For this, the CAT string is tokenized into keywords and the ‘Keyword Search’ feature of DBpedia is used to retrieve a list of Uniform Resource Identifiers (URI) that matches this tokenized CAT string. These URIs are sorted according to maximum match the keywords by DBpedia. The first URL in the list returned by DBpedia is now used for content retrieval.</p>

<p>The requirement now is to extract some text content from this DBpedia resource that can be used to display to the user. For this, use of automated queries written in the <a href="http://www.w3.org/TR/rdf-sparql-query/">SPARQL</a> Query Language for RDF (SPARQL) is made. Using this automated query, extract a short abstract, written in English language that describes the resource in a brief manner is extracted and stored. </p>

<h2><strong><em>Semantics Based Search Engine</em></strong></h2>

<p>To display the above results to the user, a user interface called the Semantics Based Search Engine (SBSE) is created in the form of a website.</p>

<p>The home page of the website asks the user to enter his query. Once the user enters his query and presses the ‘Search’ button, he is redirected to a page that shows him a dropdown list of the top ten matching ODP categories that were found after comparison with the context string _C. _Once the user selects the most relevant category, he is directed to a page that uses frames to display the short abstract retrieved from DBpedia in the left frame and a list of relevant URLs in the right frame.</p>

<p><strong>Conclusion</strong></p>

<h2>Comments</h2>

<p><strong><a href="#8657" title="2012-05-02 14:31:29">Pankaj Dhawan</a>:</strong> Nice Job Prachi.........</p>

<p><strong><a href="#7469" title="2012-02-08 15:47:00">Shruti Khattar</a>:</strong> Good job Prachi... Keep Posting :)</p>

<p><strong><a href="#7472" title="2012-02-08 17:30:55">Gagandeep Singh</a>:</strong> Good article however I couldn&#39;t see any practicability of this in real world scenarios. Few points that I could see are, 1. Very few websites provide RDF support. Even this blog don&#39;t provide that. Facebook trying to do that with open graph but that too is very limiting. 2. Users never going to select categories because they need convenience. You also have to make auto-categorization of query or display small pool of result from say top 5 categories. 3. IMO, stop words are major determiner of query context and non stop words are determiner of query category. So, I am hoping that you will take these points into consideration. And, will make better usable search engine for people like me. :)</p>

<p><strong><a href="#7473" title="2012-02-08 18:53:13">Prachi Nagpal</a>:</strong> Thank You Shruti.</p>

<p><strong><a href="#7474" title="2012-02-08 19:26:48">Prachi Nagpal</a>:</strong> @Gagandeep : Thanq for your informative points. This is one way of doing this which is being tried to portray in this blog. Well, 1. There are some difficulties with the semantics of RDF, which are currently being resolved by the RDFCore working group since benefit of using RDF wrt efficiency is obvious. 2. Many heuristic algorithms are being worked upon to compute the min-cost categorization. 3. If the sets of data are similar, the removal of stopwords may not be important to the search. But if the results or the categories aren’t similar, the stopword may be considered important and shouldn’t be removed from the query.</p>


                <hr>

                <div id="disqus_thread"></div>
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'xebiaww'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2012/02/07/selenium-web-driver-or-rc-decide-yourself/" data-toggle="tooltip" data-placement="top" title="Selenium Web Driver Or Rc Decide Yourself">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2012/02/09/liferay-5-2x-mobile-cookbook/" data-toggle="tooltip" data-placement="top" title="Liferay 5 2x Mobile Cookbook">Next Post &rarr;</a>
                    </li>
                    
                </ul>

            </div>
        </div>
    </div>
</article>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/XebiaIndia">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://www.facebook.com/XebiaIndia">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://github.com/xebiaww">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">Copyright &copy; Xebia Blog 2015</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>


</body>

</html>
